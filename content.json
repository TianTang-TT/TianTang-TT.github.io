[{"title":"在hexo中使用本地图片","date":"2018-11-02T03:35:21.000Z","path":"2018/11/02/use-local-image-in-hexo/","text":"1. 背景以前使用hexo搭建自己的博客，曾在图片如何使用上纠结过，想直接放到source中随文章一起发布上去，但是考虑到后面随着文章的增加，图片数量将会膨胀到一个令人头皮发麻的数量，大量的图片一起堆叠到一起，根本没法管理和维护了。为了图省事，最终还是使用了七牛的图床，但还是所有的图片都一起存放，没有层次感和分类，管理起来还是难受，而且每次都需要先把图片传到七牛，然后再复制外链到文章中，依然很麻烦。但好处是图片放到了七牛，因为静态资源域名跟文章域名分离开来了，所以能提升一些加载速度。 然而，前段时间七牛对域名进行了清理，因此我的博客上所有的图片都挂了，要重新绑定域名需要进行实名认证，要拍照进行人工审核，相当麻烦，当然，另一方面也是我不愿意将自己的个人资料交给这种第三方机构，痛定思痛，我决定对自己的博客图片重新进行处理 2.解决思路基本的思路还是让图片随文章一起发布，但不是杂乱无章的一股脑source下面，而是分类存放，每个文章有自己的目录，里面存放相应静态资源文件，不仅仅是图片，还可以包含视频，音频等资源文件。因为博文一般都不会有很多的图片或者视频，因此我们不需要在文件夹里面进行再次的分类，这时候跟本文章有关的图片，视频放到一起，让人一目了然。帮助我们实现这个目标的插件是 hexo-asset-image. 3.使用方法 配置hexo在hexo根目录下的_config.yml中,将post_asset_folder设置为true（默认为false) post_asset_folder: true// 此属性开启，将会在你使用命令`hexo n &apos;article name&apos; 的时候，自动在`/source/_posts下创建跟md文件同名的文件夹 安装hexo-asset-image npm i -S hexo-asset-image 创建md文件 hexo n &apos;use-local-image-in-hexo&apos; 此命令会自动在 /source/_posts下创建use-local-image-in-hexo.md和use-local-image-in-hexo文件夹。_注意_ ,只有通过hexo n命令新建的md文件才会自动创建同名的文件夹，如果是通过邮件新建文件的形式创建md文件，则不会创建同名文件夹。当我们的文章中不需要图片等资源时，可以使用手动新建md文件的方式来创建md文件，但是这样会导致有的文件是以目录\b方式存放，有的文章直接以md文件形式存放，有点混乱，不建议这么做。 source|-- _posts| |--use-local-image-in-hexo| |--use-local-image-in-hexo.md 在md中引入本地图片我们在新创建的同名文件夹中放入一张测试图片a.pngsource|-- _posts| |--use-local-image-in-hexo| | |--a.png | |--use-local-image-in-hexo.md ![本地图片](use-local-image-in-hexo/a.png) 效果 4. 生成html\b至此，我们开发过程已经完成，那么在md转化成\bhtml文件之后图片还能正常显示么，答案是肯定的","tags":[{"name":"hexo","slug":"hexo","permalink":"http://tiantang-tt.github.io/tags/hexo/"},{"name":"图床","slug":"图床","permalink":"http://tiantang-tt.github.io/tags/图床/"}]},{"title":"移动端适配方案浅析","date":"2017-09-18T06:57:03.000Z","path":"2017/09/18/h5-mobile-autofit-layout/","text":"1. 背景随着移动设备的越来越普及，各种智能手持设备日新月异，为人们带来方便快捷的生活方式和体验，而对于前端开发者来说，不同尺寸，不同平台的兼容性适配性问题却变得越来越麻烦，逐渐变成了一个让人头疼的问题。当然，魔高一尺，道高一丈，优秀的解决方案也不断涌现，如淘宝移动端适配方案lib-flexible, 网易适配方案的，真正实现了write once, run everywhere, 那么这种做法深层次的原理到底是怎么样的呢？ 2. 开发流程在前端开发之前，设计会给我们一个psd文件，称之为视觉稿。对移动端开发而言，要做到页面高清，视觉稿会遵循以下的规范： 首先会选取一款手机的屏幕宽高作为基准(iPhone6 375x667) 对于retina屏幕(如: dpr=2) ，为了达到高清效果，视觉稿的画布大小会是基准的2倍 对于我们开发来说，从设计手中拿到的应该是一份设计稿(一般是750px),以及相应的图片(@1x, @2x, @3x的图片),而我们要做的就是将设计稿还原成html页面，并且保证在不同分辨率的设备上有相同的展示效果。但是在实际的开发过程中，往往会因为屏幕大小，分辨率不同而出现一些问题。对不同屏幕大小的手机来说，如果我们使用了固定布局，如果在小屏幕手机上刚好完美布局，那么再大屏下就可能出现空隙或者留白，同样的，如果我们只考虑大屏幕的设备，那么在小屏幕上就可能会出现布局错位的情况。在某些高清屏幕(retina屏)下，1px的边框往往看起来不像是1px，因为它本可以 ‘更细’，而且某些图片在高清屏下可能会出现模糊的现象。带着这些问题，我们来一探究竟。 3. 基本概念设备像素(device-pixel) 又叫物理像素，显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(device-independent-pixel) 逻辑像素，计算机坐标系统中的一个点，该点代表一个可由程序使用并控制的虚拟像素，然后由相关系统转换为物理像素。这是一个逻辑上存在的单位，在dpr=1的屏幕下，1设备独立像素由1物理像素来渲染，而在dpr=2的高清屏幕下，当1px设备独立像素由4个一组的物理像素来渲染，比较直观的理解是1px css像素由4个物理像素来渲染(此时设备独立像素=css像素=屏宽） Css像素 是一个相对值。独立于设备的 用于逻辑上衡量像素的单位。可以理解为“直觉”像素，css和js中使用的抽象单位。一般情况下我们认为 css像素==设备独立像素 设备像素比(dpr) dpr = 物理像素/设备独立像素(在某一方向上，x方向或者y方向)，是指在移动开发中设备独立像素个css像素占用多少物理像素，如2代表1个css像素用2x2个物理像素像素来渲染。未缩放情况下，即为1css像素由多少物理像素来渲染。在js中，通过window.devicePixelRatio来获取，在css中通过device-pixel-ratio来获取。 下图中一组红绿蓝组成一个物理像素点,图像由许许多多的物理像素点组合渲染出来，最终达到我们页面上看到的效果。 在普通屏幕下，1设备独立像素(css像素）由1物理像素渲染，1:1;而在dpr为2的屏幕下，1设备独立像素(css像素)是由4物理像素来渲染，1:4。 从下面的图片中可以很直观的看出渲染效果，高清屏下渲染1css像素由更多的物理像素点来渲染，因此看上去更加的细腻清晰。 根本原理就是渲染同样尺寸的css像素，高清屏用了更多的物理像素点，使得单位面积的像素点数目更多(ppi更高) 4. 图片高清问题位图像素 一个位图像素是栅格图像(如：png, jpg, gif等),最小的数据单元。每一个位图像素都包含着一些自身的显示信息(如：显示位置，颜色值，透明度等)。 理论上来说，1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示，在一般的屏幕下，我们也确实是这么做的，假设需要显示一个200x300px的图片元素，那我们用一张200x300px的图片便能完美呈现，但是在如果在高清屏下，这么做图片就会显得有点模糊。还是以iphone6为例，又上面的内容我们可以知道，在iphone6下，1个设备独立像素实际上是由4个物理像素点来渲染，那么200x300像素的图实际上就会有400x600个物理像素点来渲染，而我们提供的图片却只有200x300，因此便会出现1个位图像素由4个物理像素点来渲染的情况，而问题是这4个像素点所取的色值跟这1个位图像素的色值是不一样的，遵循的原理是就近取色，色值只能跟这个位图像素的色值相近，而不是相同，因此图片会在高清屏下出现模糊的情况。 那么这种情况我们怎么解决呢，答案就是@2x图，也就是2倍图。这也是为什么在一开始说设计师将画布放大，提供@2x图和@3x图(为dpr为3的设备准备)的原因。在iphone6下，我们渲染一个200x300px的图，使用的将是@2x图，也就是400x600px的元素，由于1css像素由4物理像素渲染，那么一个位图像素一一对应一个物理像素，达到1:1的匹配度，高清图得以完美呈现。 但是如果我们在所有的屏幕上都是用@2x图的话，又会出现什么问题呢。前面说到了在dpr为1的屏幕下，1css像素=1物理像素，之间已经是1:1对应的关系了。还举之前的栗子，我们有一个200x300px的图片元素要渲染，提供了@2x的图来渲染这个元素，因为1css像素由1物理像素来渲染，提供的400x600像素的图就会显得有点’多余’，1个物理像素点只能就近的选取1个位图像素来渲染。虽然不会造成模糊，但是看起来图片却是损失了锐利度，而且造成了资源的浪费。 如何解决这种问题？前文中提到，我们可以在css和js中都可以获取到dpr，那么我们通过不同的dpr来加载不同的图片。针对不同的dpr，当需要图片的时候，我们可以在图片url上缀上@2x还是@3x图片的信息，比如需要一张图logo.png,它的地址是http://www.test.com/img/logo.png那么，在dpr不同的设备下，这个url的文件名应该是不同的// dpr = 1http://www.test.com/img/logo.png// dpr = 2http://www.test.com/img/logo_@2x.png// dpr = 3http://www.test.com/img/logo_@3x.png 具体到代码中，我们可以借助scss，less等工具来实现，根据不同的dpr加载不同的图片。 5. 1px边框问题图片1像素边框的问题大概是设计师比较关注的问题，那么，什么是1像素边框问题。在retina屏幕下，1px的css像素实际上是由4个物理像素来渲染的，体现在宽高上就是1px宽的border，实际上是由2px的物理像素来渲染的。设计稿上是最细的线1px的边框，在实际的retina屏幕下却是由2物理像素来渲染的，而设计师要的则是最细的1px的物理像素渲染的线。也就是说，实际上我们需要在代码中写0.5px，那这样，这条线就会由1个物理像素的宽度了。但是问题是，除了iOS 8及以上，ios7以下，android等其他系统里，0.5px会被当成为0px处理。 如何实现这样的一个0.5px的线呢，一种简单的做法就是元素的scale.scale&#123; position: relative;&#125;.scale:after&#123; content:\"\"; position: absolute; bottom:0px; left:0px; right:0px; border-bottom:1px solid #ddd; -webkit-transform:scaleY(.5); -webkit-transform-origin:0 0;&#125; 我们在代码中继续写border: 1px solid #ddd,然后通过transform:scaleY(0.5)缩小0.5倍来达到0.5px的目的，但是这样的hack不够通用(比如圆角)，写起来也很麻烦。网上解决方案也很多，这里比较推荐的还是页面整体scale方案，对于dpr=2的页面，比如iphone6，加入如下的meta标签，将页面缩放1/dpr以实现0.5px的效果。&lt;meta name=\"viewport\" content=\"width=640,initial-scale=0.5,maximum-scale=0.5, minimum-scale=0.5,user-scalable=no\"&gt; 这样可以完美实现1px物理像素的线，但是同时也带来了一些问题： 字体大小会被缩放 页面布局也会被缩放这两个问题后面会讲到。 6. 多屏适配问题做PC页面的时候，我们按照设计图的尺寸来就好，这个侧边栏200px，那个按钮50px的。可是，当我们开始做移动端页面的时候，设计师给了一份宽度为750px的设计图。那么，我们把这份设计图实现在各个手机上的过程就是『适配』。上图是著名的手淘前端团队的协作模式，而整个手淘设计师和前端开发的适配协作基本思路是： 选择一种尺寸作为设计和开发基准 定义一套适配规则，自动适配剩下的 特殊适配效果给出设计效果在设计和开发协作过程中，设计师通常会以iphone6为基准设计尺寸，交付给前端的是750x1334px的设计图，前端开发人员通过一套适配规则自动适配到其他的尺寸。在研究适配方案以前，我们先普及一下基本的概念。layout viewport layout viewport的概念其实跟pc端的viewport是一样的，是作为html的”上层“元素。将宽继承给html。html内的各元素都是以layout viewport为基准进行布局的。但跟pc端不同的是，pc端的viewport的宽是由浏览器的窗口的宽决定的，用户可以手动拖动窗口改变宽的大小。但是移动端的不同平台的浏览器呈现不同的layout viewport。 visual viewport 将visual viewport想象成覆盖手机屏幕的一个框，这个框带有类似pc端缩放的功能，而且这个框的度量单位也是css像素。这就意味着，在layout viewport不变的情况，我们能看到多少css像素的东西，取决于这个框的缩放程度。默认情况下。大多数移动端浏览器会将visual viewport这个框缩放到与layout viewport相同。 ideal viewport 理想视口，不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；显示的文字的大小是合适，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。Ideal viewport尺寸视屏幕而定，即屏幕宽度，也就是设备独立像素尺寸。 拿ios设备举例，layout viewport固定为980px，默认打开页面的情况下，visual viewport会将这个框缩放到980px。这样我们就能看到全部的内容了默认情况下html元素的宽取自layout viewport，那么不同机型浏览器的layout是不同的，ios980px，android800px。在pc端我们通过document.documentElement.clientWidth取得viewport的宽度。在移动端中，clientWidth获取的将是layout viewport的尺寸，而innerWidth获取的是visual viewport的尺寸。一般情况下我们会设置meta标签： width：控制 layout viewport 的大小。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放 meta标签中的width设置的就是layout viewport的尺寸，默认情况下，visual viewport会将页面缩放到和layout viewport同样的宽度，具体情况请看viewport知识.当我们设置以下meta标签的时候，ideal viewport = visual viewpor = layout viewport;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale = 1, user-scalable=no\" /&gt; 目前来说，移动端适配方案最实用的方案莫过于使用rem进行适配。对于rem的适配，我们要做的就是针对不同dpr不同尺寸改变html元素的font-size大小，网易的移动端适配方案，还有手淘的lib-flexible都是基于此原理的。 网易rem方案详情请查看使用Flexible实现手淘H5页面的终端适配;具体操作步骤如下。 设置以下meta标签 &lt;meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1, minimum-scale=1\"&gt; 计算html的font-size取参考标准1rem = 100px;换算关系为1px = 1/100rem；以750px设计稿为例，整体宽7.5rem；页面上以7.5rem 为参考，则1rem = window.innerWidth / 7.5 + ‘px’;所以document.documentElement.style.fontSize = window.innerWidth / 7.5 + ‘px’; 也就是说html的font-size大小，即rem始终是1rem = 屏幕宽度/(设计稿宽度/100),由此可算出以下设备的html的font-size值 iphone 5 ：320/7.5 = 42.667px iphone 6 : 375/7.5 = 50px; iphone 6p: 414/7.5 = 55.2px; 查看网易新闻的webapp页面，跟我们的计算值一样。当然，对640的设计图来说，这个基准值就由7.5变成了6.4，其他步骤还是不变的，参考设计图写代码的时候，仍然是1rem = 100px，在别的尺寸屏幕下就会进行自动适配。理论上来说，1rem可以设置为任意值的px，为什么要取100这个系数，是因为这样是为了方便进行rem值的计算。如果设计稿中有一个200x300px的元素，那我们可以直接口算出rem值width: 2rem;height: 3rem 但是这个方案仍然有弊端，在retina屏幕下，1css像素依然由多个物理像素来渲染，由此带来的1px边框问题仍然没有得到解决，只是解决了布局自动适配的问题。 手淘lib-flexible方案 在flexible中，只对iOS 进行了判断，对于安卓设备，始终认为其dpr为1. if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; flexible会根据dpr动态计算页面的缩放值，将scale设置为1/dpr,这样一来，由于将页面缩小为原来的1/dpr倍,使得1css像素正好对应1物理像素。 docEl.setAttribute('data-dpr', dpr); if (!metaEl) &#123; metaEl = doc.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement('div'); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; &#125; 动态设置html的font-size值，将其设置为页面宽度width的十分之一(hack 10vw);即1rem = clientWidth/10,将页面整体分为10分，也就是10rem。lib-flexible中使用getBoundingClientRect来计算html的宽度，后期改为clientWidth。 function refreshRem()&#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125; 经过这样的设置，根据dpr动态缩放页面，使得1css像素对应1物理像素，然后将html的font-size设置为页面宽度的1/10进行布局的适配。例如，750px的设计稿，通过计算html的font-size应该是750/10 = 750px, 即1rem = 75px;在iphone6下，屏宽375px；由于dpr为2，那么scale将为0.5，因此，经过缩放的页面layout viewport的宽度应该为750px，刚好跟设计稿对应，设计稿中200x300px的区域，写代码的时候也是200x300px,然后将px转化为rem就可以了。这个转化工作可以使用插件来做，或者用postcss的插件px2rem来进行转化。 优点 通过缩放页面，使得1css像素对应1物理像素，解决了由此带来的1px边框问题和布局适配问题。 缺点 rem需要动态的计算，口算难度有点大，需要借助插件或者构建工具。并且没有考虑ipad或者dpr不为1的安卓，在这些设备下依然存在1px边框问题。 上面两种方案无论是网易的适配方案，还是flexible方案，都需要加载一段js来动态的计算rem，flexible可以看成是网易方案的加强版，都可以满足适配的条件。而对于字体来说，我们希望在不同尺寸的设备上看到同样大小的文字，不希望文本在retina屏幕下变小，另外我们希望在大屏幕上看到更多的文字。而现在绝大多数字体文件都带一些点阵尺寸，通常是16px， 24px，不希望出现13px， 17px这样的尺寸，而rem计算出来的尺寸却很可能出现这些奇数尺寸。如此一来，在写h5页面的过程中，rem并不适合应用到文本上，所以flexible中建议文本不使用rem做单位，仍然用px，只不过需要通过[data-dpr]属性区分不同dpr设备下的字体大小。div &#123; width: 1rem; height: 0.4rem; font-size: 12px; // 默认写上dpr为1的fontSize &#125; [data-dpr=\"2\"] div &#123; font-size: 24px; &#125; [data-dpr=\"3\"] div &#123; font-size: 36px; &#125; 当然也可以用过scss less这样的css预处理工具来处理@mixin font-dpr($font-size)&#123; font-size: $font-size; [data-dpr=\"2\"] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr=\"3\"] &amp; &#123; font-size: $font-size * 3; &#125; &#125; flexible2.0方案上面介绍的lib-flexible方案其实是对vw/vh的hack，而随着移动端对vw/vh的逐渐支持，这种hack也会慢慢变得没有必要。flexible2.0方案便直接使用vw/vh进行适配。当然这样做也是存在风险的，因为还有很多设备不支持vw/vh,直接使用这种方案略显激进。而且不缩放页面，1px问题又会随之出现。 以上是关于移动端适配性问题的一点浅薄理解，如有不对的地方，还望指正。 参考资料部分观点引用下面资料。http://www.w3cplus.com/css/viewports.htmlhttp://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.htmlhttp://www.w3cplus.com/css/towards-retina-web.htmlhttps://div.io/topic/1092https://segmentfault.com/a/1190000004403496https://github.com/jawil/blog/issues/21https://zhuanlan.zhihu.com/p/25216275http://www.cnblogs.com/lyzg/p/4877277.htmlhttp://www.cnblogs.com/lyzg/p/5058356.htmlhttp://web.jobbole.com/90084/https://www.w3cplus.com/css/vw-for-layout.html","tags":[{"name":"h5","slug":"h5","permalink":"http://tiantang-tt.github.io/tags/h5/"},{"name":"mobile","slug":"mobile","permalink":"http://tiantang-tt.github.io/tags/mobile/"},{"name":"viewport","slug":"viewport","permalink":"http://tiantang-tt.github.io/tags/viewport/"}]},{"title":"postMessage实现页面间通信","date":"2017-07-03T09:21:54.000Z","path":"2017/07/03/postMessage-in-html5/","text":"1.前言跨域问题是前端开发中的常见问题，我们一般的解决方案无非是配置反向代理，jsonp或者cors，这些方案在前后端交互中比较有用，但是在某些场景下，这些手段就略显乏力。比如客户端页面之间的通信，子页面和父页面的通信，或者不同tab页面之间的通信，这时候由于浏览器同源策略的限制，会造成跨域问题，父子页面间无法进行通信，更不要提tab页签之前的通信。当然我们可以通过websocket这类的双工通信方式来解决，但是这需要经过服务端，而html5中postMessage的出现便可以很好地解决这种问题 2.简介window.postMessage() 方法可以安全地实现跨源通信。通常，当且仅当两个页面具有相同的协议（通常为https），端口号（443为https的默认值），以及主机(模数 Document.domain 由两个页面设置为相同的值)才可以进行通信。 window.postMessage() 方法提供了一种受控机制，以便在正确使用时以安全的方式规避此限制。 window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（e.g., 在该方法之后设置的事件、之前设置的timeout 事件,etc.）向目标窗口派发一个 MessageEvent 消息。 3.基本语法postMessage otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow 其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是”*“。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。 [transfer] 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 当目标窗口接收到消息之后会触发一个message事件，将MessageEvent对象传进来，因此我们可以通过为目标窗口添加message事件来监听通信。而父页面上发过来的信息以及相应的事件属性 4. 使用示例那么具体怎么使用呢？主要是通过otherWindow.postMessage(message, targetOrigin)来调用。比如我们要跟iframe内嵌的iframe通信，那么这个otherWindow就是这个iframe的window对象，我们可以通过document.querySelector(&#39;#iframeid&#39;).contentWindow来获取，然后通过postMessage方法来发送消息。而在iframe页面收到消息时，会触发一个message事件，接受一个messageEvent对象，从父页面上传进来的消息和相关事件的属性就挂载在这个messageEvent对象上。我们可以通过监听messge来接受父页面上传过来的消息 window.addEventListener(\"message\", event); event 对象中主要包含以下属性。 data 从其他 window 中传递过来的对象，通过event.data获取。在 Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3)之前， 参数 message 必须是一个字符串。 从 Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3)开始，参数 message被使用结构化克隆算法进行序列化。这意味着你可以将各种各样的数据对象安全地传递到目标窗口，对象或者数组，而不仅仅是可以发送字符串。 origin 调用 postMessage 时消息发送方窗口的 origin ，通过event.origin获取。此属性用来判断发送方的身份，防止恶意的第三方向页面发送恶意消息进行攻击.要注意的是，当你的页面使用非服务器环境（也就是直接双击打开页面）时这个属性值为null，在本地进行测试时请注意这一点，因为你可能拿不到origin的值。因此最好使用nginx或者Apache之类的web容器进行测试。 source 调用 postMessage 时消息发送方window对象的引用，可以借此实现两个页面之间的实时通信，通过event.source获取 父页面代码&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;parent&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;this is parent window&lt;/p&gt; &lt;input type=\"text\" id=\"parentMsg\"&gt; &lt;button id=\"sendParentMsg\"&gt;发送信息到iframe&lt;/button&gt; &lt;div class=\"contents\"&gt; &lt;p&gt;这里会展示收到的信息&lt;/p&gt; &lt;/div&gt; &lt;iframe src=\"demo.html\" frameborder=\"2\" id=\"childIframe\" height=\"500\" width=\"800\"&gt;&lt;/iframe&gt;&lt;script&gt; var origin, win; // 为父页面绑定message事件，接受来自iframe发送的消息 window.addEventListener('message', event =&gt; &#123; document.querySelector('.contents').innerHTML += `&lt;p&gt; 收到信息：$&#123;event.data&#125;, 来自于$&#123;event.origin&#125;&lt;/p&gt;`; &#125;); // win可以是iframe的引用，也可以是通过通过父页面打开的子页面的window引用，比如子页面是通过window.open打开的，那么win可以是win = window.open(url, '_blank'),这样便可以实现两个tab页之间的通信 win = document.querySelector('#childIframe').contentWindow; document.querySelector('#sendParentMsg').addEventListener('click', () =&gt; &#123; var parentMsg = document.querySelector('#parentMsg').value.trim(); if (parentMsg) &#123; win.postMessage(parentMsg, '*'); document.querySelector('#parentMsg').value = ''; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; iframe页面代码&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;child&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;this is iframe page&lt;/p&gt; &lt;label for=\"subpageInput\"&gt; 请输入信息&lt;/label&gt; &lt;input type=\"text\" id=\"subpageInput\"&gt; &lt;button class=\"sendSubpage\"&gt;发送信息到父页面&lt;/button&gt; &lt;div class=\"contents\"&gt; &lt;/div&gt;&lt;script&gt; var parentWin, parentOrigin; // 监听来自父页面的消息 window.addEventListener('message', event =&gt; &#123; parentOrigin = event.origin; // 获取发送方页面的origin，通过判断此属性来识别发送方的身份 parentWin = event.source; // 获取发送发window对象的引用，可以通过这个对象调用postMessage方法实现父子页面互相通信。 document.querySelector('.contents').innerHTML += `&lt;p&gt;iframe 收到信息：$&#123;event.data&#125;, 来自于$&#123;event.origin&#125;&lt;/p&gt;`; &#125;); document.querySelector('.sendSubpage').addEventListener('click', () =&gt; &#123; var subMessage = document.querySelector('#subpageInput').value.trim(); if (subMessage) &#123; // submessage为要发送的信息，'*'为指定某个域接受信息 parentWin.postMessage(subMessage, '*') document.querySelector('#subpageInput').value = ''; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5. 使用场景(1) 页面之间的通信当你使用多页应用时，需要两个页面之间进行实时的通信，而又不想通过服务端进行websocket之类借助服务端实现的通信，那postMessage将是一个很好的方式。子页面可以通过window.open方法打开，var win = window.open(pageurl, &apos;_blank&apos;);那么这个win就是新打开的tab窗口的引用，可以同win.postMessage方法来对新打开的tab页发送消息。当你在新打开的页面监听message事件，便可以从message事件对象中得到原页面发送的消息，同时可以得到原页面的window对象的引用source，这时候就可以在新的页面上利用这个source调用postMessage方法来对原页面发消息。这样就实现了两个页面的实时通信。 (2) 通过iframe授权登录当公司有多个网站或者多款产品，而这些网站的账号密码是可以通用的，比如我注册了我司的网站a，那么我再登录我司的网站b的时候就可以通过网站a的用户名和密码来登录网站b，类似于令牌一样的，那么你只需要做一套登录页面就可以。实现的原理很简单，比如我们需要在index.html页面上需要进行某个操作，而这个操作需要用户登录之后才可以进行，那我们便可以通过引入一个iframe，或者打开一个新的tab页面来让用户进行登录(这个iframe页或者新的tab页就是我们需要的登录页)，然后在index上监听message事件，当登录成功或者失败之后，通过postMessage将登录结果发送回index页面，这样父页面便可以通过这个登录结果进行后续的操作。 6. 安全隐患页面监听到message事件之后必须对源页面合法性进行校验，也就是说你必须校验event.origin属性，确保这个消息是可信页面发送过来的，否则如果是恶意的第三方网站发送的恶意代码，那么可能造成一些严重的后果。例如你的站点监听着一个message，并且没有判断message的来源，导致可以给他发message，message中有websocket的url的话，站点会和发送message的站点建立websocket链接，并且会把认证后的token传递给发送者站点。再比如你是需要将event.data的值进行dom操作，如果恶意的第三方将xss攻击代码加入data，那么如果你不校验消息来源的合法性的话，就很可能造成xss攻击。如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器,否则，请始终使用origin和source属性验证发件人的身份。 // 校验origin合法性的方法,如果只想接受来自'https://verify.com'的消息window.addEventListener('message', event =&gt; &#123; var origin = event.origin; if (/^https:\\/\\/verify.com$/.test(origin)) &#123; // 此处进行敏感操作 &#125; else &#123; // 当校验不通过，则什么也不做，丢弃此消息 &#125;&#125;) 7. 浏览器兼容情况","tags":[{"name":"html5","slug":"html5","permalink":"http://tiantang-tt.github.io/tags/html5/"},{"name":"postMessage","slug":"postMessage","permalink":"http://tiantang-tt.github.io/tags/postMessage/"}]},{"title":"nginx配置https","date":"2017-04-18T09:18:49.000Z","path":"2017/04/18/config-https-in-nginx/","text":"1. 前言在chrome下使用google地图api的时候发现没有反应，不能获取用户的地理位置，查看控制台后发现必须要使用https请求，而我的nginx服务器配置为http请求，因此打算在nginx中配置https。配置步骤如下。 2. 准备条件操作系统：windows 10服务器： Nginx安装Openssl下载地址：http://slproweb.com/products/Win32OpenSSL.html （根据系统选择32位或者64位版本下载安装）。下载完成后，进行安装，我安装在了E:\\environment\\OpenSSL-Win64文件夹中。 配置环境变量在环境变量中添加环境变量 变量名： OPENSSL_HOME 变量值：E:\\environment\\OpenSSL-Win64\\bin;（变量值为openssl安装位置） 在path变量结尾添加如下 ： %OPENSSL_HOME%; 3. 配置步骤(1). 创建ssl目录 首先在 nginx安装目录中创建ssl文件夹用于存放证书。比如我的文件目录为 C:\\nginx\\ssl,以管理员身份进入命令行模式，进入ssl文件夹。 命令为 cd c:/nginx/ssl (2). 创建私钥 在命令行中执行命令： openssl genrsa -des3 -out server.key 1024 // （server文件名可以自定义）// 在此过程中需要你输入密码，并在此输入密码，请务必记住此密码，后面会用到 (3). 创建csr证书 在命令行中执行命令： openssl req -new -key server.key -out server.csr // key文件为刚才生成的文件，server为自定义文件名 执行上述命令后，需要输入信息。输入的信息中最重要的为 Common Name，这里输入的域名即为我们要使用https访问的域名。因为我是本地测试，因此我在此中配置为localhost.在执行完上述两个命令之后，ssl文件家中会出现两个文件server.key和server.csr (4). 去除密码 在加载SSL支持的Nginx并使用上述私钥时可以去除口令，否则会在启动nginx的时候需要输入密码。 在命令行中执行命令： openssl rsa -in server.key -out server.key// 执行此命令需要输入刚才设置的密码 (5). 生成crt证书 在命令行中执行命令： openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt // server为自定义文件名 此条命令执行完之后ssl文件夹中应该多出了server.crt文件 4. 配置Nginx上述步骤完成之后，我们需要的证书就已经生成了，现在只需要配置一下nginx就好了。nginx的配置文件位于 nginx/conf/nginx.cof在http下新建一个如下的serverhttp &#123; include mime.types; default_type application/octet-stream; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; # 这是你新配置的https的server，可直接将一下内容复制到你的conf文件中 server &#123; listen 443 ssl; server_name localhost; # 刚才生成的srt文件和key文件 ssl_certificate c:/nginx/ssl/server.crt; ssl_certificate_key c:/nginx/ssl/server.key; # 下面一堆干嘛的我也不懂 ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; # 这是你的其他server server &#123; &#125; 完成配置后重启Nginx，在浏览器地址栏输入https://localhost（https默认端口是443，因此这里可以省略），便可成功访问。 5. 结语我们自己生成的证书是不受信任的，因此某些浏览器会弹窗警告证书不受信任，点击继续就行。当然这仅仅是我们为了开发测试自己生成的证书，如果是正式的生产环境，请从正规的CA中获取受信任的证书。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://tiantang-tt.github.io/tags/nginx/"},{"name":"https","slug":"https","permalink":"http://tiantang-tt.github.io/tags/https/"}]},{"title":"websocket实现聊天室功能，仿微信pc端","date":"2017-01-09T11:02:21.000Z","path":"2017/01/09/websocket-chatroom/","text":"1. 前言随着浏览器对html5的支持，我们现在可以用前端做一些很有意思的事情，比如在线聊天室，今天就谈谈怎么用nodejs+websocket实现一个简单的在线聊天室。本文用socket.io打造一个在线聊天室，取名为uchat，‘有聊’或者叫‘友聊‘。 2.主要技术和模块前端 socket.io 封装了websocket，提供了友好的api，使用方便 template-native.js art-template模板引擎 后台 nodejs v6.9.1，基本支持了es6语法 express 静态资源服务器 socket.io websocket库，后台也得支持websocket不是吗 思路 主要模拟微信网页端的交互和UI，通过socket.io来发送和接受消息，支持emoji表情和图片的发送。发送图片主要是利用了html5的FileReader，然后发送dataurl，这样只需要将img标签的src设置为base64的url就可以正常显示图片了。至于emoji的发送，因为每个客户端的emojis都是一样的，所以emoji本身并不会经过socket来传输，传输的仅仅是一个特定的emoji编码，这样前端接收到这个编码之后就可以正常显示相应的emoji了。 3. 主要代码前端html代码具体就不展示了，感兴趣的可以查看 uchat;主要讲解一下node端的实现和前端的思路。服务端主要用了socket.io，这个前面已经说过了，既然是聊天室，那肯定就需要展示在线人员列表以及在线人数，因此我用了es6的Map对象存储当前在线人员，因为可以它方便的进行增删改查，如果有用数组来实现的话要相对麻烦很多。在建立连接对象的时候创建一个Map对象map，利用socket对象的id来作为连接用户的唯一表示，也把它作为用户在map对象中的唯一key（map中的key不允许重复）。然后通过socket来监听一个自定义login事件，当用户在前端发触发login的时候，后端将当前连接的socketId作为key，然后创建一个对象存储用户数据，包括用户名以及一些其他用户数据，然后将这个key和对象存储到map中，同时将用户登录的消息广播到其他的客户端。当某个用户在前端发送了消息之后，服务端接受消息，并把它转发到除了发送者之外的所有客户端中。图片和表情的发送也是类似的思路。当某个客户端断开连接之后，服务端监听到disconnet时间，然后将该用户从map对象中移除，然后将消息广播给其他客户端。 const users = new Map();const socketIO = io =&gt; &#123; // 当用户在客户端发送websocket请求和服务端建立socket连接之后会触发服务端的connection事件 io.on('connection', socket =&gt; &#123; // 每个客户端都有一个连接对象，其中id属性为唯一标识 let userId = socket.id; // 监听登陆事件，用户登陆之后将用户信息存储于map对象中 socket.on('login', name =&gt; &#123; let headline = ''; if (!isLogin(userId)) &#123; users.set(userId, &#123;name, headline&#125;); let msg = `$&#123;name&#125; joined`; // 通知其他用户有人加入群聊 io.sockets.emit('message', &#123;type: 'system', data: msg&#125;); io.sockets.emit('membersChange', userArr()); &#125; &#125;); // 接受消息事件 socket.on('message', msg =&gt; &#123; if (isLogin(userId)) &#123; socket.broadcast.emit('message', msg); &#125; &#125;) // 从在线列表中删除断连用户 socket.on('disconnect', () =&gt; &#123; let user = users.get(userId); let msg = `$&#123;user.name&#125; left`; users.delete(userId); socket.broadcast.emit('membersChange', userArr()); socket.broadcast.emit('message', &#123;type: 'system', data: msg&#125;); &#125;); // 判断用户是否已登陆 function isLogin (id) &#123; if (users.has(id)) &#123; return true; &#125; return false; &#125; function userArr() &#123; let values = users.values(); return [...values] &#125; &#125;);&#125; 以上是服务端的主要逻辑，清晰明了，代码也不多，那么在客户端呢。首先我们引入了socket.io的库（前后端都用了socket.io，只不过前端是客户端的socket.io），写了一个登陆界面，需要填入用户昵称，毕竟你需要知道消息是谁发来的。填入昵称，点击登陆之后才会建立socket连接，因为这时候才能算你登陆成功，否则将不会在后端的map对象中存储用户信息。登陆之后就进入了群聊界面，主要三部分，用户列表，对话区，输入区。建立了一个全局的uchat对象来保存一个客户端实例，构造这个对象的同时绑定了登陆逻辑，当用户成功登陆之后就可以进行这个实例的初始化了。实例的初始化主要包括以下的部分，获取当前在线的用户列表，绑定一些页面的事件，比如发送消息，发送图片，选择表情。当用户点击表情按钮的时候进行表情的下载（不放在初始化中是为了提高首页加载速度），然后展示表情面板。 写输入区的时候遇到一个问题，我之前使用textarea来做的输入区，用来发送文本消息，传送图片也没有问题因为图片不会在输入区显示，而是选择好之后就直接发送了，没有后悔药。但是发表情的时候不能这样搞啊，先得在输入区显示，然后万一点错了还可以删除或者更换，然后可以图文一起发送。但是textaera中是不能显示图片表情的，这个问题有点蛋疼，想了很久也没有想到合适的解决方案，于是查看了网页微信，发现是用的p标签来做的输入区，然后设置contenteditable为true，真一语惊醒梦中人，图片在p标签中可以显示啊，于是我将输入区修改为了p标签，这样就可以愉快的选择输入表情了。但是还有个问题，那就是每个客户端要选的表情都是那么些，每个表情在客户端都有（你要发表情肯定得提前在客户端下载好）,每次都通过socket直接传输表情数据岂不是显得很浪费，白下那么多表情了？那么既然每个用户的可选择表情都是一样的，而且客户端本地下好了这些表情，如果我知道别的客户端发来的是什么表情，直接显示我本地的表情不就好了？恩，看起来没毛病，那么我怎么知道对方发来的是什么表情呢？？？在这里，我对每个表情都制定了一个编号，构建了一定的规则，表情的类型编号都是[emoji:type_number]的形式，type是表情类型，number是具体的表情编号，跟表情图片的文件名保持一致，这样就能直接通过编号来找到指定的表情了。所以表情面板中的img标签都会有data-type和data-num两个属性。当用户选择某个表情之后，js会复制这个表情的img标签，然后显示在下方的输入区中，这样就能在输入区中显示图片了。点击发送键的时候先对输入区内容做过滤，把img标签换成[emoji:type_number]的形式发送，当别的客户端收到一段文本消息之后也做过滤，把其中的[emoji:type_number]换成相应的img标签，这样就能在对话区显示相应的图片了。 var uchat = null;window.onload = function () &#123; uchat = new UChat(); uchat.login(); &#125;function UChat () &#123; this.socket = null; this.emojiLoaded = false;&#125;UChat.prototype = &#123; login: function () &#123; var self = this; var loginPage = document.querySelector('#login'); var userInput = loginPage.querySelector('.username'); var loginBtn = loginPage.querySelector('.btn-login'); loginBtn.addEventListener('click', join); userInput.addEventListener('keydown', function (e) &#123; if (e.keyCode === 13 || e.code.toLowerCase() === 'enter') &#123; join(); &#125; &#125;); function join () &#123; var username = userInput.value; if (!username.trim().length) &#123; alert('请输入昵称'); return; &#125; userInput.value = ''; loginPage.style.display = 'none'; self.name = username; self.init(); &#125; &#125;, init: function () &#123; var self = this; // 显示左侧用户资料 this.displayProgile(); // 链接到服务器 this.socket = io.connect(); // 建立连接 this.socket.on('connect', function () &#123; // 此处需要展示登陆界面 self.socket.emit('login', self.name); &#125;); this.socket.on('message', function (msg) &#123; self.addDialogItem(msg); &#125;); // 当前群聊人员变动 this.socket.on('membersChange', function (memberArr) &#123; // 更新在线人员列表 self.upDateMemItem(memberArr); &#125;); this.bindEvent(); &#125;, displayProgile: function () &#123; var self = this; var profile = document.querySelector('#members .profile'); profile.querySelector('.nick-name').innerText = self.name; &#125;, /** * [bindEvent 绑定事件入口] * @return &#123;[undefined]&#125; */ bindEvent: function () &#123; // 发送消息 this.bindSendMsg(); // 发送表情 this.bindSendEmoji(); // 发送图片 this.bindSendImg(); &#125;, /** * [bindSendMsg 发送信息] * @return &#123;[type]&#125; [description] */ addDialogItem: function (data) &#123; // 接收到后台发来的信息然后在对话区展现出来 // &#123;type: 信息类型, data: 具体的信息&#125; var html = template('msgTpl', data); // 过滤，将表情代码换成图片 html = this.codeToImg(html); var dialogArea = document.querySelector('#chatting .dialogs'); dialogArea.innerHTML += html; // 消息更新后滚动条滚到底 dialogArea.scrollTop = dialogArea.scrollHeight; &#125;, /** * [upDateMemItem 更新在线人员列表] * @param &#123;[type]&#125; memberArr [description] * @return &#123;[type]&#125; [description] */ upDateMemItem: function(memberArr)&#123; var memHtml = template('memTpl', &#123;memberArr: memberArr&#125;); var memList = document.querySelector('.mems-list'); memList.innerHTML = memHtml; document.querySelector('#dialog .count').innerText = memberArr.length; &#125;, bindSendMsg: function () &#123; var self = this; var speakArea = document.querySelector('#typing #typeContent'); var sendBtn = document.querySelector('#typing .btn-send'); // 点击按钮发送 sendBtn.addEventListener('click', sendMsg); // 回车发送 speakArea.addEventListener('keydown', function (e) &#123; if (e.keyCode === 13 || e.code.toLowerCase() === 'enter') &#123; sendMsg(e); &#125; &#125;); function sendMsg (e) &#123; var speaking = speakArea.innerHTML; speaking = self.imgToCode(speaking); if (speaking.trim().length) &#123; self.socket.send(&#123;msgType: 'text', data: speaking, username: self.name&#125;); // 把信息显示在对话区域 self.addDialogItem(&#123;type: 'self', data: speaking, username: self.name&#125;); // 清空输入区 speakArea.innerHTML = ''; e.preventDefault();//这句话可以阻止回车事件冒泡;如果注释掉这句话,那么会有空格残余; &#125; &#125; &#125;, bindSendImg: function () &#123; var self = this; var file = null; var reader = null; var fileName = ''; var imgReg = /\\.(jpg|jpeg|png|gif)$/; var imgInput = document.querySelector('#typing .uploadImg'); imgInput.addEventListener('change', function () &#123; if (!this.files.length) &#123; return; &#125; file = this.files[0]; fileName = file.name; if (!imgReg.test(fileName.toLowerCase())) &#123; alert('请选择一张图片'); imgInput.value = ''; return; &#125; reader = new FileReader(); // 图片读取完毕之后马上显示 reader.onload = function (e) &#123; self.addDialogItem(&#123;type: 'self', data: e.target.result, msgType: 'img', username: self.name&#125;); self.socket.send(&#123;type: 'dialog', msgType: 'img', data: e.target.result, username: self.name&#125;); imgInput.value = ''; &#125; reader.readAsDataURL(file); &#125;) &#125;, bindSendEmoji: function () &#123; var self = this; var emojiTool = document.querySelector('#typing .tools .emoji'); var container = emojiTool.querySelector('.emoji-container'); var emojiSelector = container.querySelector('.selector'); var emojiTab = container.querySelector('.tab'); var img, qqFragment, tsjFragment; emojiTool.addEventListener('click', function (e) &#123; var qqSection = container.querySelector('section[data-type=qq]'); var tsjSection = container.querySelector('section[data-type=tsj]'); if (container.clientHeight &gt; 10) &#123; container.style.display = 'none'; &#125; else &#123; container.style.display = 'block'; &#125; // 下载表情 if (!self.emojiLoaded) &#123; qqFragment = document.createDocumentFragment(); tsjFragment = document.createDocumentFragment(); // qq表情75个 for (var i = 1; i &lt;= 75; i++) &#123; img = document.createElement('img'); img.setAttribute('data-type', 'qq'); img.setAttribute('data-num', i); img.src = 'assets/imgs/qq/' + i + '.gif'; qqFragment.appendChild(img); &#125; qqSection.appendChild(qqFragment); // 兔斯基表情18个 for (var j = 1; j &lt;= 69; j++) &#123; img = document.createElement('img'); img.setAttribute('data-type', 'tsj'); img.setAttribute('data-num', j); img.src = 'assets/imgs/tsj/' + j + '.gif'; tsjFragment.appendChild(img); &#125; tsjSection.appendChild(tsjFragment); self.emojiLoaded = true; &#125; e.stopPropagation(); &#125;); // 选择表情类型 emojiSelector.addEventListener('click', function (e) &#123; var target = e.target.parentNode; var type = target.getAttribute('data-type'); if (!type) &#123; return; &#125; var sections = container.querySelectorAll('.emoji-list'); [].slice.call(sections).forEach(function (item) &#123; var itemType = item.getAttribute('data-type'); if (itemType === type) &#123; item.style.display = 'block'; &#125; else &#123; item.style.display = 'none'; &#125; &#125;); e.stopPropagation(); &#125;); // 选择表情 emojiTab.addEventListener('click', function (e) &#123; var target = e.target; var type = target.parentNode.getAttribute('data-type'); var num = target.getAttribute('data-num'); if (!type || !num) return; var speakArea = document.querySelector('#typing #typeContent'); speakArea.innerHTML += target.outerHTML; container.style.display = 'none'; e.stopPropagation(); &#125;) // 点击空白处隐藏表情面板 document.addEventListener('click', function () &#123; container.style.display = 'none'; &#125;); &#125;, imgToCode: function (str) &#123; var emojiReg = /&lt;img.+?data-type=\"(\\w+)\".+?data-num=\"(\\d+)\".*?&gt;/g; return str.replace(emojiReg, '[emoji:$1_$2]'); &#125;, codeToImg: function (str) &#123; var codeReg = /\\[emoji:(\\w+?)_(\\d+?)\\]/g; return str.replace(codeReg, '&lt;img src=\"assets/imgs/$1/$2.gif\"&gt;'); &#125;&#125; 4. 总结 也没什么好说的，写这种长文总是缺乏耐心。 5. 参考Node.js + Web Socket 打造即时聊天程序嗨聊;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://tiantang-tt.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://tiantang-tt.github.io/tags/nodejs/"},{"name":"websocket","slug":"websocket","permalink":"http://tiantang-tt.github.io/tags/websocket/"},{"name":"socket.io","slug":"socket-io","permalink":"http://tiantang-tt.github.io/tags/socket-io/"}]},{"title":"node爬虫抓取知乎动态","date":"2016-12-22T08:12:20.000Z","path":"2016/12/22/node-crawler/","text":"前言 以前一直以为爬虫是一种很高级的黑客手段，显得很神秘，近来有空，便想用nodejs来写一个小爬虫一探究竟。 主要构想 nodejs为前端接触后端架起了一座桥梁，现在后端能做的很多事情，我们用nodejs也能来实现，比如爬虫。作为前端工程师，我选用nodejs 来实现这个小爬虫。此文中以spider来代替该爬虫。spider的主要作用是用来爬取自己知乎账号的最近动态，获取自己的基本资料，然后抓取两百条数据 来分析自己最近都做了哪些操作，当然，你可以抓取更多，这是可以配置的。控制台的数据可视化并不是很好，因此用express搭建了简单的服务器，通过浏览器 来预览爬虫的抓取结果。 使用模块superagent 发起http请求，请求知乎接口来获取数据 cheerio 抓取页面后操作dom来提取页面中的数据，api及用法跟jquery类似 express 用来起简单的服务，以便于在浏览器中查看爬虫抓取的的数据 jade 页面模板引擎 使用方法 克隆该仓库到本地，然后安装相应的模块 执行node app来启动服务 打开浏览器，输入localhost:3000便可查看效果 分析 整个爬虫其实很简单，主要作用就是发送请求收集数据然后进行分析，当然分析这一步不一定算到爬虫里面，可以自己写别的模块来进行数据的分析和加工。用superagent请求知乎接口拿到特定的数据，然而有的接口是有限的，有的数据是通过服务端渲染直接显示在页面上的，不能通过知乎的接口直接拿到，所以需要从渲染好的页面上进行抓取，因此需要用到cheerio模块来进行dom操作，拿到相应的dom结构然后取值。这里需要注意的是这种需要登录的网站请求可能会有权限验证，因此需要在发请求的时候为请求带上相应的cookie和authorization的数据，否则将请求就失败，为了获取cookie和authorization，所以做了一个登陆入口来获取相应的授权。 目录说明 主要步骤 通过邮箱密码验证码登陆获取授权，获取cookie以及authorization 通过请求zhihu.com来获取用户id，然后用cheerio抓取出来进行后续的操作 拿到userid之后就可以进行用户基本资料以及最近动态的请求 登陆和获取授权的过程有点麻烦，而且有验证码，所以只能通过express来做一个转发。有兴趣的可以直接看github代码及相应的注释，此处不详细讲代码 demo test 效果 github地址带登陆功能的知乎爬虫","tags":[{"name":"node","slug":"node","permalink":"http://tiantang-tt.github.io/tags/node/"},{"name":"spider","slug":"spider","permalink":"http://tiantang-tt.github.io/tags/spider/"},{"name":"crawler","slug":"crawler","permalink":"http://tiantang-tt.github.io/tags/crawler/"}]},{"title":"jsonp跨域的原理","date":"2016-12-01T09:26:07.000Z","path":"2016/12/01/principle-of-jsonp/","text":"1. 前言jsonp是一种常用的跨域手段，和反向代理，服务端做跨域处理相比，jsonp更显得方便轻巧，因而被大量用来处理跨域的请求，那么，这种请求方式到底是用了什么黑魔法，来解决令我们头疼的跨域问题。 2. 原理jsonp其实并没有用到什么黑魔法，能达到跨域这种效果，无非是利用script标签自身的跨域能力。我们知道，img,script,这种标签如果有相应的src，那么便会发起一个htttp请求来请求相应的资源,如果有script标签对应的路径是一个js文件，那么在下载完毕这个js之后会马上执行 &lt;script type=\"text/javascript\" src=\"www.somewhere.com/test.js\"&gt;&lt;/script&gt;&lt;!--此时会发起一个请求来获取test.js，下载完成之后会立即执行test.js--&gt; 假设我们需要从’www.localhost.com&#39;发起一个获取数据的请求&#39;www.somewhere.com/getdata&#39;,如果有我们以ajax来发起请求，那么由于浏览器同源保护策略的限制，该请求的返回值不会被浏览器所接受，这就是跨域问题。但是script这种标签会发起一个get请求，并且这个请求是不受同源策略限制的，如果有我们将&#39;www.somewhere.com/getdata&#39;以script标签来发送变成如下请求方式，那么是不是就不会有跨域问题了 &lt;script type=\"text/javascript\" src=\"www.somewhere.com/getdata\"&gt;&lt;/script&gt;&lt;!--需要这样一个script来发起get请求--&gt; 答案是肯定的，这也是jsonp跨域的原理。但是同时，这里也出现了两个问题，第一，怎么使用script来发送请求，第二，请求得到的数据应该怎么在前端页面上接收并处理。对于第一个问题，我们一般会将script标签写在html文档中，当我们通常遇到的都会是动态请求，如果有我们还像原来一样把标签提前写好在html中，那么浏览器解析文档到这个script标签时就会立即发起请求，等我们想要用到这些数据时，再去找前面加载好的数据，这样显然太费时费力，不太灵活，而且页面上如果有很多请求，岂不是要提前些很多script标签在页面上，这样页面丑陋的根本没法看了。我们需要的是在请求服务的时候，再发起请求，那么我们完全可以用动态标签来实现，通多document.createElement来动态创建一个script标签，然后为其设置src属性，等请求完毕之后再将script标签移除，那么第一个问题便迎刃而解了。 let script = document.createElement('script');srcipt.src = 'www.somewhere.com/getdata';document.querySelector('head').appendChild(script); 但同时，这也产生了第二个问题，我们怎么知道请求什么时候完毕，请求回来的数据要怎么处理,以及,请求完毕之后要怎么清除标签。前面说到过，script标签下载完毕之后会立即执行（async和defer暂时按下不表），而我们的请求通常会返回一个json对象，然而json直接执行是要报错的，如{“name”: “柳轻侯”, “job”: “FE”}.如果花括号位于语句句首，那么花括号中的内容会被识别为一个语句块，外层的花括号会被直接忽略，如果是{name: ‘柳轻侯’, job: ‘FE’}这种形式可能并不会报错，因为即使忽略了花括号，name: ‘柳轻侯’也是一个合法的js语句，叫做标签语句，但是如有给标签语句加上引号，”name”: “柳轻侯”，这种形式却并不合法，因为标签语句不可以用引号引起来，然而json的key却必须用双引号引起来，所以直接返回一个json是不行的，必须返回一个可执行的js语句才行。而且一般来说我们需要请求结果来执行一些js逻辑操作，那么我们的操作逻辑要写在哪里，怎么跟返回结果相结合呢？这时候就需要callback出场了。我们可以把请求结果”包装”一下,将数据的处理逻辑写到一个函数中，然后在script的结果中来调用这个函数，把需要的数据传给这个函数，那么一切问题就都可以解决了。假设请求结果内容是{“name”: “柳轻侯”, “job”: “FE”},处理这个结果的函数叫callback // 结果的处理，callback函数，必须在script请求之前就已经在页面上声明或赋值function callback (data) &#123; console.log(data.name)&#125;// 注意，script一定要返回一个js文件，文件内容是用回调函数将请求结果包装起来，形成函数调用的形式// 文件内容callback(&#123;\"name\": \"柳轻侯\", \"job\": \"FE\"&#125;) 但是如果页面上有多jsonp请求，总不能所有的回调函数都叫callback吧，那么这时候就需要指定回调函数的名字，不同的jsonp请求调用不同的回调函数。可以通过script请求将函数名传到服务端，然后服务端相应的将结果用此函数名包装，然后返回到前端，这样就可以按名称调用了。我们将请求做以简单的封装。 function getJSONP (url, callback) &#123; let script = document.createElement('script'); script.type= \"type=\"text/javascript; srcipt.src = url + '?callback=' + callback; document.querySelector('head').appendChild(script);&#125; 如果有这时候有两个请求需要处理，”www.somewhere.com/getdata1&quot;和&quot;www.somewhere.com/getdata2&quot;两个请求需要处理，请求结果分别是{&quot;name&quot;: “柳轻侯”, “job”: “FE”}和{“name”: “天棠”, “job”: “fe”},处理函数分别是dealData1和dealData2,那我们该怎么处理？ function getJSONP (url, callback) &#123; let script = document.createElement('script'); script.type= \"type=\"text/javascript; srcipt.src = url + '?callback=' + callback; document.querySelector('head').appendChild(script);&#125;const dealData1 = function (data) &#123; console.log('这是getData1的回调:' + data.name);&#125;const dealData2 = function (data) &#123; console.log('这是getData1的回调:' + data.name);&#125;// 分别发送请求getJSONP('www.somewhere.com/getdata1', 'dealData1'); // www.somewhere.com/getdata1?callback=dealData1getJSONP('www.somewhere.com/getdata2', 'dealData2'); // www.somewhere.com/getdata1?callback=dealData2 // 请求结果分别是dealData1(&#123;\"name\": \"柳轻侯\", \"job\": \"FE\"&#125;)dealData2(&#123;\"name\": \"天棠\", \"job\": \"fe\"&#125;)//执行结果这是getData1的回调: 柳轻侯这是getData2的回调: 天棠 这时候两个结果会分别用传过去的callback来包装，然后输出不同的结果,这时候我们的需求基本上被满足了，最后还要处理的一点，每发一条请求，页面上被凭空创建了一个script标签，如果有请求很多，那么页面上就会多出很多无意义的标签（请求结束之后相应的标签就失去了意义），所以我们需要在请求处理结束之后清除创建的script标签。但是页面上还有别的script标签，必须只清除当前请求的jsonp生成的标签，如果将其他的script标签，可能就会造成其他的严重问题。由于每个jsonp的回调函数名称不一样，我们可以通过回调函数名来找出我们想要清除的script。 const dealData1 = function (data) &#123; console.log('这是getData1的回调:' + data.name); // 处理完毕之后清除相应的script标签 let callbackName = arguments.callee.name; document.querySelector('script[src*=\"callback=' + callbackName + '\"]').remove();&#125; 3. jsonp的缺点 只能发送get请求。因为script只能发送get请求 需要后台配合。此种请求方式应该前后端配合，将返回结果包装成callback(result)的形式。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://tiantang-tt.github.io/tags/javascript/"},{"name":"jsonp","slug":"jsonp","permalink":"http://tiantang-tt.github.io/tags/jsonp/"}]},{"title":"js事件顺序执行","date":"2016-10-06T03:51:50.000Z","path":"2016/10/06/event-sequence/","text":"1. 前言前几天朋友问到一个问题,js中的依次绑定多个点击事件，那么这些事件的执行顺序跟绑定顺序有联系吗？当然通过属性绑定事件只能绑定覆盖之前的事件，此处按下不表。通过addEventListener和attachEvent可以为dom对象绑定多个事件，由于某些原因，可能并不会将执行逻辑写到同一个处理程序中，而是在代码执行的不同阶段先后添加了处理不同逻辑的事件，那么事件的执行顺序是按照添加的顺序执行的吗，如果不是，该怎么让事件顺序执行。 2. 分析为dom绑定多个事件有两个方法，addEventListener和attachEvent，前者是属于dom2级事件，支持ie9及以上，chrome,ff,通过此方法为dom绑定的事件会按照绑定的先后顺序执行，然而对于ie8以下的浏览器，并不支持dom2级事件，只能使用attachEvent来绑定事件，此方法虽然也可以绑定多个事件，但是事件的执行顺序确实与绑定顺序截然相反。 var btn = document.querySelector('btn');document.addEventListener('click', function () &#123; alert('first');&#125;);document.addEventListener('click', function () &#123; alert('second');&#125;);// 点击按钮之后先弹出'first',后弹出'second'var btn = document.querySelector('btn');document.attachEvent('click', function () &#123; alert('first');&#125;);document.attachEvent('click', function () &#123; alert('second');&#125;);// 点击按钮之后先弹出'second',后弹出'first' 3. 多个事件顺序执行如果因为业务需要一定要让绑定的事件按顺序执行，且支持ie8，那我们不得不对这两种方法做兼容。通过看jquery代码得到启发，我们可以把每次绑定的事件的事件处理程序通过压栈操作压入数组，当事件触发的时候，通过数组的迭代来顺序执行数组中的函数.这样一来，事件处理程序其实是和dom结构完全解耦了，不再是直接绑定在dom上，而是存储在一个数组中。这样一来，事件处理程序的执行作用域可能就会发生变化，那么我们需要在迭代数组的时候将上下文传入，这样就可以完美解决了。 var DomEvent = function (dom) &#123; if (!dom) &#123; return ; &#125; this.el = dom;&#125;;DomEvent.prototype = &#123; constructor: DomEvent, add: function (type, func) &#123; var el = this.el, self = this; eventList = this[type + 'Events']; if (!eventList) &#123; if (el.addEventListener) &#123; el.addEventListener(type, function () &#123; self._fire(type); &#125;); &#125; else if (el.attachEvent) &#123; el.attachEvent('on' + type, function () &#123; self._fire(type); &#125;); &#125; else &#123; el['on' + type] = function () &#123; self._fire(type); &#125; &#125; this[type + 'Events'] = []; &#125; this[type + 'Events'].push(func); &#125;, _fire: function (type) &#123; var eventList = this[type + 'Events']; if (!eventList) &#123; return; &#125; //ie8不支持forEach,需要做兼容 eventList.forEach(function (func) &#123; func.call(this.el); &#125;) &#125;&#125;;var div = document.querySelector('#test');var des = new DomEvent(div);des.add('click', function () &#123; alert('first');&#125;);des.add('click', function () &#123; alert('second');&#125;)//先弹出first,然后是seconddes.add('mouseover', function () &#123; alert('over1');&#125;)des.add('mouseover', function () &#123; alert('over2');&#125;)//鼠标滑过时先弹出over1，然后是over2 4.原理至此，顺序添加的事件都能顺序执行，且支持ie8（forEeach自己去做兼容），核心思想就是把多个事件合并为一个事件，在这个事件中顺序执行不同时段添加的处理程序，通过数组压栈来控制调用顺序。也就是所有的事件公用一个入口，然后在入口中处理调用顺序，依次调用。 5.缺点使用此方法有个缺点，那就是每个dom结构只能创建一个DomEvent对象，这导致如果需要在不同的作用域下为同一个dom结构绑定事件，必须将DomEvent对象创建在全局下，或者某个相对独立的作用域的父级作用域。如果为同一个dom结构创建对个DomEvent对象，那么将与原生绑定方法无异。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://tiantang-tt.github.io/tags/javascript/"},{"name":"event","slug":"event","permalink":"http://tiantang-tt.github.io/tags/event/"}]},{"title":"短小精悍的js代码段","date":"2016-09-22T04:23:56.000Z","path":"2016/09/22/pretty-js-pieces/","text":"前言一些令叹为观止的js精巧代码 js代码段生成随机颜色 // 生成十六进制的随机颜色let color16 = function () &#123; return \"#\" + (function (color) &#123; return new Array(7 - color.length).join(\"0\") + color; &#125;)((Math.random() * 0x1000000 &lt;&lt; 0 ).toString(16));&#125;;color16(); // \"#dd90f2\"color16(); // \"#d8b15e\"color16(); // \"#036f98\" 生成固定位数的随机id // 生成固定位数的随机idfunction generateTipId () &#123; var tipId = ''; for (; tipId.length &lt; 16; tipId += Math.random().toString(36).substr(2)); return tipId.substr(0, 16);&#125;;generateTipId() // \"tbi34lo197o3z7y7\"generateTipId() // \"qgpyetdfp1hhdy2y\"generateTipId() // \"0qz3mcts495rg126\"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://tiantang-tt.github.io/tags/javascript/"}]},{"title":"js隐式类型转化例子分析","date":"2016-06-29T05:45:57.000Z","path":"2016/06/29/js-type-transform/","text":"1.前言偶然间看到一段很有意思的代码，一段不含任何字母数字，只包含各种括号，加减号的代码执行结果出现了’sb’一个字符串，(eval(‘(!(~+[])+{})[–[~+””][+[]][~+[]]+~~!+[]]+({}+[])[[~!+[]~+[]]]’)结果返回’sb’)真是amazing，当时百思不得姐，回过头仔细想想，一段段的分析一下，原理便水落石出了。 2.思路eval('(!(~+[])+&#123;&#125;)[--[~+\"\"][+[]]*[~+[]]+~~!+[]]+(&#123;&#125;+[])[[~!+[]*~+[]]]') //'sb' 乍一看毫无头绪，这段代码中没有任何英文，也没有数字，那么字符串’sb’是怎么出现的？仔细分析，代码中多次出现了’!’,’+’，’!’的作用是取反，返回一个布尔值，那么可能会出现’false’或者’true’，那么我们要的’sb’中的’s’已经出现，而’+’有一个重要的作用，那就是等同于Number()函数的效果，将值转为number类型，并且有拼接字符串的作用，如果’+’的一边是字符串而另一边不是，那么将会被隐式的转换为字符串类型并进行拼接。到这里，思路应该很清晰了，某些被转换后的值会出现英文字母和数字，然后再结合’[]’那么就可以取到相应的字母了。下面来具体分析原理。 3.具体分析(!(~+[])+&#123;&#125;)[--[~+\"\"][+[]]*[~+[]]+~~!+[]]+(&#123;&#125;+[])[[~!+[]*~+[]]]//将上面代码进行拆分，可得到如下部分(!(~+[])+&#123;&#125;) ，[--[~+\"\"][+[]]*[~+[]]+~~!+[]] ， (&#123;&#125;+[]) ， [[~!+[]*~+[]]]//分别将上述四部分用$1,$2,$3,$4来表示，即求$1和$2的运算结果 + $3和$4的运算结果。var $1, $2, $3, $4; $1 = (!(~+[])+&#123;&#125;); $2 = [--[~+\"\"][+[]]*[~+[]]+~~!+[]]; $3 = (&#123;&#125;+[]); $4 = [[~!+[]*~+[]]];//分析$1 = (!(~+[])+&#123;&#125;);运算顺序为先计算(~+[]),然后对其取反，再与&#123;&#125;相加(~+[]) //返回-1， +[]此处的加号相当Number函数，所以+[]返回0，再对其进行按位非操作，即取相反数再减去1!(~+[]) //返回falsefalse + &#123;&#125; //返回'false[object Object]', 一元加操作符会将布尔值和对象通过toString()方法分别 //转为'false'和'[object Object]'//所以$1的运算结果为'false[object Object]'//分析$2 = [--[~+\"\"][+[]]*[~+[]]+~~!+[]]; 先计算--[~+\"\"][+[]]，然后计算[~+[]]，两相作乘，然后与~~!+[]的结果相加--[~+\"\"][+[]] //返回-2，[~+\"\"]返回[-1],[+[]]返回[0]，即为--[-1][0] //由于方括号[]优先级高于--， 所以返回-2[~+[]] //返回[-1]--[~+\"\"][+[]]*[~+[]] //返回2，一元乘操作符会将非数字转为数字，[-1]被转为-1,即为(-2)*(-1) ~~!+[] //返回1，~操作符会将布尔值转为number[2 + 1]//所以$2的运算结果为[3]//分析$3 = (&#123;&#125;+[]),一元加操作符会将对象通过toString()分别 转为'[object Object]' 和 ''(&#123;&#125;+[]) //返回'[object Object]'//所以$3的运算结果为'[object Object]'//分析$4 = [[~!+[]*~+[]]];先计算~!+[]，后计算~+[]，然后结果相乘~!+[] //返回-2~+[] //返回-1[[~!+[]*~+[]]] //返回[[2]]//所以$4的运算结果为[[2]]//因此整个表达式可以简化为'false[object Object]'[3] + '[object Object]'[[2]]//返回'sb'//此处要注意'string'[[2]]这种写法，string后面跟方括号，里面需要一个number类型的数值n来返回'string'//的第n位上的字符，因此方括号里面的值会被通过Number()方法转为数值类型，[2]被转为2 4.总结1.主要考察js中隐式类型转换,一元+和~操作符将值转为number类型的值，相当于Number方法2.当+操作符两边类型不同时，若有一边为字符串，则将另一边也转为字符串，然后执行拼接。3.将对象转为基本类型值时，先调用valueOf方法，若还是对象，则调用toString方法。4.数组的valueOf方法返回其自身。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://tiantang-tt.github.io/tags/javascript/"}]},{"title":"HTMLCollection和NodeList以及NamedNodeMap之间的关系","date":"2016-06-27T12:10:11.000Z","path":"2016/06/27/HTMLCollection-NodeList-NamedNodeMap/","text":"1.前言之所以把这三者放到一起，是因为这三个对象都是”Array-like”的（类数组）,它们具有像数组一样的特性，比如具有length属性，都可以通过索引[index]来获取相应的元素。更为重要的是，它们都是’live’的，是’有生命有呼吸的对象’，这么说是因为这三者都是动态的，会实时更新查询dom结构。 2.背景&lt;!--有如下dom结构--&gt;&lt;div id=\"t1\" class=\"active\"&gt; &lt;div id=\"tt1\"&gt;&lt;/div&gt; &lt;div id=\"tt2\"&gt;&lt;/div&gt; &lt;div id=\"tt3\"&gt;&lt;/div&gt;&lt;/div&gt; var nodelist = document.getElementById('t1').childNodes;var htmlcollections = document.getElementsByTagName('div');var attrs = document.getElementById('t1').attributes;nodelist instanceof NodeList //truehtmlcollections instanceof HTMLCollection //trueattrs instanceof NamedNodeMap //true 由上面可以看出，通过getElemetnsByTagName获取的是一个HTMLCollection,从方法名来看，getElementsByTagName是通过标签名获取到的一个元素的集合，是elements(元素)的集合，虽然说这些元素中可能包含其它非element节点，比如text节点，但是这些节点是附属于某个element的，并不是通过tagName来获取到的。element.childNodes获取到的是一个NodeList，是Node(节点)的 集合，可能同时包括element节点其他节点，例如上面代码中的nodelist就有7个节点，其中3个element，4个text节点(在ie9及以下的浏览器中空白符不算入文本节点)。element.attributes获取的则是一个特性Attribute集合，而集合中的每一个元素，都是Attr类型的对象。Attr对象有三个属性，name、value和specified。但是在日常应用中，一般会应用getAttribute()、setAttribute()和romoveAttribute()来操作特性，不需要直接访问特性对象。 3.定义interface HTMLCollection &#123; readonly attribute unsigned long length; Node item(in unsigned long index); Node namedItem(in DOMString name);&#125;;interface NodeList &#123; Node item(in unsigned long index); readonly attribute unsigned long length;&#125;;interface NamedNodeMap &#123; Node getNamedItem(in DOMString name); Node setNamedItem(in Node arg) raises(DOMException); Node removeNamedItem(in DOMString name) raises(DOMException); Node item(in unsigned long index); readonly attribute unsigned long length; // Introduced in DOM Level 2: Node getNamedItemNS(in DOMString namespaceURI, in DOMString localName); // Introduced in DOM Level 2: Node setNamedItemNS(in Node arg) raises(DOMException); // Introduced in DOM Level 2: Node removeNamedItemNS(in DOMString namespaceURI, in DOMString localName) raises(DOMException);&#125;; 由上面接口定义可以看出， 这三种对象都可以通过[index]来便利查找，都可以通过item(index)方法来查询对应的值，但是HTMLCollection实例比NodeList实例和NamedNodeMap实例多了namedItem方法 ，NamedNodeMap的实例则是有更多的取值设值得api,但在开发中我们一般用getAttribute()、setAttribute()和romoveAttribute()来操作特性，不需要直接访问特性对象。对类数组而言，我们可以把它们转成真正的数组，以便使用以下数组的特有方法。 var divs = document.getElementsByTagName(\"div\"); divs instanceof Array; //falsevar divArray = Array.prototype.slice.call(divs); divArray instanceof Array; //true divArray.forEach(function(item,index)&#123; //do something &#125;) 4.注意var divs = document.getElementsByTagName(\"div\"), i, div; for (i = 0; i &lt; divs.length; i++) &#123; div = document.createElement(\"div\"); document.body.appendChild(div); &#125; 以上代码是无限循环，HTMLCollection、NodeList以及NamedNodeMap这三个集合都是“动态的”，每当文档发生变化时，他们都会更新。他们将始终保持这最新、最准确的消息。我们知道dom操作是很”昂贵”的，频繁的进行dom操作会造成性能的极大损耗，在上面的for循环中，每循环一次都要查一遍dom结构来获取最新的信息，如果dom结构很复杂嵌套很深，那么这种查找的性能损耗就可想而知了。因此我们可以把查询结果缓存到一个变量中就可以避免每次都查找的窘境了。 var divs = document.getElementsByTagName(\"div\"), i, len, //len用来缓存divs的长度，创建一个number副本，避免每次都查找 div; for (i = 0, len = divs.length; i &lt; len; i++) &#123; div = document.createElement(\"div\"); document.body.appendChild(div); &#125; 值得一提的是querySelectorAll()也将会返回一个NodeList(如果存在)，但是这时候的NodeList却并不是动态的，而是类似于一个快照一样，并不会实时查询，因为这个NodeList是一个StaticNodeList 5.总结1.理解HTMLCollection，NodeList以及NamedNodeMap各自代表了，有哪些共性。2.它们都是类数组，有length属性，[index]取值方法。3.他们都是动态的，必要的时候要缓存起来。4.querySelectorAll()返回一个静态StaticNodeList。 6.参考资料 js便签笔记（1）——说说HTMLCollection、NodeList以及NamedNodeMap Document Object Model Core Document Object Model HTML","tags":[{"name":"HTML","slug":"HTML","permalink":"http://tiantang-tt.github.io/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://tiantang-tt.github.io/tags/javascript/"}]},{"title":"js常用正则校验","date":"2016-06-16T11:20:27.000Z","path":"2016/06/16/js-common-regs/","text":"1.前言这篇文章主要收集整理了常用的javascript的正则验证表达式，一部分为我工作中遇到的需要校验的规则，还有一些是我遇到的比较经典的js正则表达式，希望能对你有所帮助，若有疑问，请联系我。（持续更新中） 2.常用js正则表达式// 大于等于1的数(包含小数)/^[1-9]\\d*(\\.\\d+)?$/// 大于1的数(包含小数)/^(?!1+$)(?!1\\.0+$)[1-9]\\d*(\\.\\d+)?$/// 只能输入数字，字母，特殊字符，且三者必须全都包含，8位以上/^(?!\\D+$)(?![^a-zA-Z]+$)(?![\\da-zA-Z]+$).&#123;8,&#125;$/// trim方法，去除white space,BOM，换行符/[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+/g// 二代身份证是18位，一代身份证是15位/^(\\d&#123;15&#125;|\\d&#123;14&#125;x|\\d&#123;18&#125;|\\d&#123;17&#125;x)$/i// 手机号码验证/^(13[0-9]|14[5|7]|15[0-9]|18[0-9])\\d&#123;8&#125;$///邮箱格式校验/^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/// 邮编共6位，第一位不为0/^[1-9][0-9]&#123;5&#125;$/// ip校验/^((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))$/// 是否包含中文/[\\u4E00-\\u9FA5]+/g// 检测月份是否合法/^(\\d&#123;4&#125;)-(0[1-9]|1[012])$/// 检测日期是否合法/^(\\d&#123;4&#125;)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/// 检测带时间日期是否合法/^(\\d&#123;4&#125;)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])\\s(0\\d&#123;1&#125;|1\\d&#123;1&#125;|2[0-3]):[0-5]\\d&#123;1&#125;:([0-5]\\d&#123;1&#125;)$/// 如何优雅的实现金钱格式化：1234567890 --&gt; 1,234,567,890/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g","tags":[{"name":"RegExp","slug":"RegExp","permalink":"http://tiantang-tt.github.io/tags/RegExp/"},{"name":"正则","slug":"正则","permalink":"http://tiantang-tt.github.io/tags/正则/"}]},{"title":"前端开发规范","date":"2016-06-08T06:34:36.000Z","path":"2016/06/08/FE-guide/","text":"前言软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就需要，此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写API文档、执行同行评审。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码。 全局变量的问题全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。 由于JavaScript的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码： // 不推荐写法: 隐式全局变量 function sum(x, y) &#123; result = x + y; return result;&#125;//推荐写法，始终使用var声明变量function sum(x, y) &#123; var result = x + y; return result;&#125; 另一个创建隐式全局变量的反例就是使用任务链进行部分var声明。 var a = b = 0; //a是局部变量但是b却隐式的创建了全局变量 //另外，变量是不可通过delete操作符删除的 访问全局变量在浏览器中，全局对象可以通过window属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的window标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作： var global = (function () &#123; return this;&#125;());//严格模式下不可用 单var形式在函数顶部使用单var语句来声明变量，将此作用域中可能用到的变量事先声明，防止变量在定义之前使用的逻辑错误和重复声明。你也可以在声明的时候做一些实际的工作，例如前面代码中的sum = a + b这个情况，另外一个例子就是当你使用DOM（文档对象模型）引用时，你可以使用单一的var把DOM引用一起指定为局部变量，就如下面代码所示的： function func() &#123; //将此作用域中要用到的变量提前声明 var a = 1, b = 2, sum = a + b, myobject = &#123;&#125;, i, j; // function body...&#125;var el = document.getElementById('result') //缓存dom引用，避免每次使用都要查找 变量和声明提前JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。看下面这个例子： // 反例myname = 'global'; // 全局变量function func() &#123; alert(myname); // 'undefined' var myname = 'local'; alert(myname); // 'local'&#125;func(); for循环在for循环中，你可以循环取得数组或是数组类似对象的值，譬如arguments和HTMLCollection对象。这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码执行效率，尤其当myarray不是数组，而是一个HTMLCollection对象的时候通常的循环形式如下 // 反例// 次佳的循环for (var i = 0; i &lt; myarray.length; i++) &#123; // 使用myarray[i]做点什么&#125; 集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的.这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的： //当myarray是一个NodeList的时候更能凸显这种方法的优异性for (var i = 0, max = myarray.length; i &lt; max; i++) &#123; // 使用myarray[i]做点什么&#125; for- in 循环for-in循环应该用在非数组对象的遍历上，使用for-in进行循环也被称为“枚举”。从技术上将，你可以使用for-in循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。有个很重要的hasOwnProperty()方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。思考下面一段代码 (不)扩展内置原型扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的JavaScript方法来持续不断地工作，而不是你另加的方法。另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。因此，不增加内置原型是最好的。 switch形式你可以通过类似下面形式的switch语句增强可读性和健壮性： var inspect_me = 0, result = '';switch (inspect_me) &#123;case 0: result = 'zero'; break;case 1: result = 'one'; break;default: result = 'unknown';&#125;//每个case和switch对齐（花括号缩进规则除外）//每个case中代码缩进//每个case以break清除结束//避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。//以default结束switch：确保总有健全的结果，即使无情况匹配。 避免隐式类型转换JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。 var zero = 0;if (zero === false) &#123; // 不执行，因为zero为0, 而不是false&#125;// 反面示例if (zero == false) &#123; // 执行了...&#125; 避免(Avoiding) eval()__ 请避免使用这个方法，用其他方法代替来实现你想要的效果 parseInt()下的数值转换(Number Conversions with parseInt())使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数。 var month = '06', year = '09';month = parseInt(month, 10);year = parseInt(year, 10); 缩进建议使用tab缩进（1tab === 4space) 花括号花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在in或是for中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。想象下你有一个只有一条语句的for循环，你可以忽略花括号，而没有解析的错误。 //建议左花括号写在表达式后面if(true) &#123; alert('It is TRUE!');&#125;// 警告:意外的返回值function func() &#123; return // 下面代码不执行 &#123; name : 'Batman' &#125;&#125; 命名规范构造函数：首字母大写普通函数：驼峰式写法文件命名：驼峰式写法内部函数：前面加下划线_ 空格//参数列表和for循环, 和 ; 前不允许有空格。// goodcallFunc(a, b);for(var i = 0; i &lt; 5; i++)//比较操作符&lt; , &gt; , =两边加空格if(a &lt; b)if(a == b)//对象创建时，属性中的 : 两边必须有空格。var obj = &#123; a : 1, b : 2, c : 3&#125;; 引号js中单引号和双引号并没有明显的含义区分，用单引号和双引号都可以，但为了规范性，我们有一下建议 //在html中用双引号，在js代码中用单引号//&lt;input type=\"file\" value=\"upload\"&gt;&lt;/input&gt;var a = \"verisTest\";//注意，在json中必须用双引号，否则可能会出错var jsonObj = &#123; \"a\" : \"1\", \"b\" : 2&#125; 分号分号代表某段语句的结束，在js中某些语句后面可以不加分号，因为js解析引擎正在解析代码的时候会自动识别并添加分号，但是并非所有情况都能正确识别，因此我们建议在每个结束语句后面都添加分号。 a = b(function()&#123;...&#125;)()会被解释为 a = b(function()&#123;...&#125;)() 参考文章 翻译-高质量JavaScript代码书写基本要点","tags":[{"name":"开发","slug":"开发","permalink":"http://tiantang-tt.github.io/tags/开发/"}]},{"title":"浏览器本地存储,localStorage,sessionStorage","date":"2016-04-07T11:39:46.000Z","path":"2016/04/07/localStorage-sessionStorage/","text":"1.前言一般来说，当我们首次登陆某个网站的时候，浏览器会默认提供一个“记住密码”的功能来询问你是否需要浏览器来记住你的登陆密码，这些密码会以加密的形式安全的存放在你的本地磁盘上。但是我们需要的往往并不仅仅是记住密码而已，有时候我们希望存储更多的信息在本地。浏览器tab页中的信息通常会在关闭标签页的时候销毁，只有那些保存在cookie的信息会被写入到磁盘中，所以当你再次打开浏览器的时候，除了cookie中的信息，你上次访问网页的信息将会全部丢失，因此我们不得不一次次的输入那些重复的信息，白白浪费自己的时间，而现在，html5提供的本地存储功能webStorage可以帮我们完美的解决这个问题。 2.webStorage以往我们用cookie来将需要的信息保存到本地，下次需要这些信息的时候直接从cookie中获取就可以了，这种便捷的方式一直以来是web开发人员本地存储的主要方式，但这种方式也有自己的弊端，比如cookie大小有限制，相当轻量，因此能存放的信息量不大，而且每发请求都会带上相应的cookie，如果cookie中包含敏感信息，那么这种行为就相当危险了。web Storage主要有以下两个目标 提供一种cookie之外存储的会话的途径. 提供一种可以存储大量可以跨会话存储的机制 支持webStorage的浏览器的window上定义了两个属性，localStorage和sessionStorage,这两个属性都是storage对象的实例，下面是storage接口的定义 interface Storage &#123; readonly attribute unsigned long length; DOMString? key(unsigned long index); getter DOMString? getItem(DOMString key); setter void setItem(DOMString key, DOMString value); deleter void removeItem(DOMString key); void clear();&#125;; 所以localStorage和sessionStorage也拥有setItem,getItem,removeItem等方法，下面分别来讲这两种存储方法各有什么特点。ps:下文中的webStorage对象指的是localStorage或sessionStorage 3.localStorage和webStorage由于webStorage中信息的存储（目前）只能存储字符串，所以如果存储别的类型的数据，会被浏览器默认转为字符串存储起来。 //api//若key不存在，则创建该key,并把相应的值设为value，//若key已经存在，则判断当前value和原始值oldvalue是否相等，若相等，则do nogthing，什么也不做(__注意:此种情况不会触发事件)//若key存在且value!=oldvalue,则用value覆盖oldValue;setItem(key,value):存储一条记录//若key不存在，则do nothing，什么也不做(__注意:此种情况不会触发事件)//若key存在，则返回该key相对应的valuegetItem(key):获取一条记录//若key不存在，则do nothing，什么也不做(__注意:此种情况不会触发事件)//若key存在，则清除对应的记录removeItem(key):清除一条记录clear():清除当前webStorage对象的所有键值对//若n&gt;length,则返回nullkey(n):获取第n条记录的key//获取当前webStorage对象的记录条数length:总数属性 这里要注意的一点是可以通过设置属性来存储一条记录，通过查询该属性来获取该记录，通过delete操作符来删除该记录(非ie8及以下) var ls = localStorage;ls.setItem(\"name\",\"honor\") //等价于ls.name = \"honor\"ls.setItem(\"name\",\"柳轻侯\") //直接覆盖原来的oldvalue,相当于ls.name = \"柳轻侯\"ls.removeItem(\"name\") //等价于delete(ls.name),此举仅在非ie8下生效 4.生命周期和作用域如我们所知，cookie可以设置domain和cookie,那么localStorage和sessionStorage是否也有作用域和生命周期呢，答案是显然的，并且不同的作用域和生命周期是localStorage和sessionStorage的主要区别。和cooie不同，ls(localStorage)和ss(sessionStorage)有默认的作用域和生命周期，ls存储的数据是永久性的(存储在用户的磁盘上)，除非用户可以得去清除存储的数据，否则将一直存在下去，不会过期。 可读取共同ls的文档应该是同源的(同协议，同域，同端口)，通源文档分享同一个ls对象，可以相互读取或覆盖对方的数据，两个不同窗口tab页之间可以相互通信，没有类似于cookie的path限制，或者你可以把ls的path当成’/‘。但有一点需要注意，虽然同源文档共同维护同一个ls对象，且这个ls对象是存储在用户的磁盘上的，但是 不同的浏览器却又有相对独立的作用域，比如你使用chrome为www.test.com设置了一个ls对象，你用FireFox访问www.text.com却访问不到上次在chrome中设置的ls对象，别的浏览器也一样。 ss对象的生命周期一般是当前window对象的生命周期，也就是说除非当前tab页关闭，否则这个ss对象是一直存在的，当然前提是你刷新的tab页跟之前的页面是同源的(同协议，同域，同端口)。但是不同的window之间是不可以共享同一个ss，即使两个window的url是一模一样的，也就是说，不同的tab页之间的信息共享是被严格限制的，no way!. 5.存储事件只要ls或ss的数据对象发生改变，浏览器在其他对该数据可见的窗口对象上会触发存储事件（在对数据进行改变的窗口上反而不会触发，也就是说同源的a页面和b页面，如果a页面中对ls对象做出修改，那么会在b页面上触发存储事件，而a页面上却不会触发。（__注意： 只有数据真正发生改变时才会触发存储事件，do nothing的情况是不会触发事件的）。 我们可以通过dom2的事件监听方法addEventListere方法监听storage事件 //与storage事件相关的五个属性（ie8不支持）key: 被设置或移除的键名字，如果为clear事件，则该属性为nullnewVlaue：被设置项的新值，如果书removeItem事件，则该属性为nulloldValue: 被设置或移除的项的原始值，若该项是新增项，则该属性是nullstorageArea: 目标window对象上的localStorage属性或sessionStorage属性url: 触发该事件的文档的url 6.浏览器支持 chrome和safri的ss和ls大小限制为2.5Mb,其他浏览器为5Mb,这个容量足以应对大部分需求。要特别注意，ie8不支持delete操作符，为保证兼容性，应该尽量使用stemItem,getItem，removeItem 7.总结总体来说html5的本都存储还是很强大的，可以我们大部分需求，但并非所有浏览器都实现了这个接口，所以在使用之前最好先检测一下看浏览器是否支持ls和ss。另外，目前ls和ss都只能存储字符串，如果想要存储一些复杂的接口，可将其先转化为字符串然后存储，用的时候再将格式还原。","tags":[{"name":"localStorage","slug":"localStorage","permalink":"http://tiantang-tt.github.io/tags/localStorage/"},{"name":"sessionStorage","slug":"sessionStorage","permalink":"http://tiantang-tt.github.io/tags/sessionStorage/"},{"name":"webStorage","slug":"webStorage","permalink":"http://tiantang-tt.github.io/tags/webStorage/"},{"name":"浏览器本地存储","slug":"浏览器本地存储","permalink":"http://tiantang-tt.github.io/tags/浏览器本地存储/"}]},{"title":"javascript中的相等操作符","date":"2016-04-05T04:41:56.000Z","path":"2016/04/05/equal-in-js/","text":"1.前言我们在编程的过程中，经常会遇到判断两个变量是否相等的情况，ECMAscript提供了两种相等操作符”==”和”===”来判断，这两种操作都会返回一个boolean值。一般来说，我们把”==”称之为相等，称”===”为全等。当两相比较的两个变量数据类型一致时，情况比较简单，而当操作符两边的变量类型不一致，甚至其中的某个变量是对象时，情况就比较复杂了，下面分别介绍当操作数类型不同时运算结果会怎么样。 2.全等操作符 “===”全等操作符”===”的情况相对来说比较简单。当用全等操作符”===”来判断时，首先检查操作符两边操作数数据类型是否一致，若不一致，则直接返回false,否则，才进行下一步判断。如果是两个boolean的比较，则”===”两边必须同为true或同为false,才可以返回true,否则返回false.若两相比较的是数字，那么只有当这两个数字大小相等时才会返回true，否则返回false。如果要比较的两个变量是字符串，先比较两个字符串的长度length是否相等，如果长度不一样，则返回false,如果相等，则从两个变量的第一个字符开始比较是否相等，一直比较到最后一位，如果其中的某一位不想等，则返回false,否则返回true,(注意:字符串的比较是不会忽略空格的，所以在比较两个字符串是否相等时，为确保安全，应该先去除空格，然后把两个字符串同转为大写或者小写之后再进行比较)。而null只有在null===null的情况下才会返回true,其它情况都返回false,同样，undefined只有在undefined===undefined的情况下才会返回true,否则返回false。如： //若数据类类型不同，则直接返回falsetrue === 1 //false\"1\" === 1 //false //boolean的比较true === true //truetrue === false //false//string的比较\"hello\" === \"helloworrld\" //false\"hello\" === \"world\" //false\"hello\" === \" hello\" //false\"hello\" === \"hellO\" //false\"hello\" === \"hello\" //true//number的比较1 === 1 //true1 === 1.0 //true1 === 1.2 //false//null和undefined的比较undefined === undefined //truenull === null //trueundefined === null //false,两者在\"==\"时才返回true 如果进行”===”比较的两个操作数不是基本类型值，而是两个对象，这时候判断依据就是，判断这两个变量是否是”同一个”对象 var a,b,c;a = b = &#123; name : '柳轻侯', city : '南京'&#125;;c = &#123; name : '柳轻侯', city : '南京'&#125;;a === b //truea === c //false 两个对象仅仅”长得一样”是不够的，a和c都是Object实例，且两者拥有相同的属性和值，可是这两个却不是”同一个”对象，因为实际上a和c指向了两个不同的实例，所以这两个对象是不全等的。而a和b却是指向了同一个对象，换个说法，a和b是同一个对象的不同别名，他们实际上指向的对象是完全相同的，所以a === b。”!==” 与 “===” 比较规则一样，在此不再赘述。 3.相等操作符”==”全等操作符在进行判断的时候，如果两个变量的类型不同，则直接返回false,而与此不同，”==”相等操作符在判断的时候，如果两个变量的类型不同，则会做一个隐式的类型转换，把要比较的两个值转化为相同的类型再做比较，那么这种转化规则是怎么样的？ 在转化不同数据类型时，相等和不等操作符遵循下面的基本规则 如果其中一个操作数是是boolean值，则在比较之前会先将boolean值转化为number值，true转化为1，false转为0; 如果其中一个操作数是string类型，而另一个是number类型，则在比较之前先将string类型转化为number类型再进行判断; 在比较之前，undefined和null是不会转为其他值进行比较的; 如果其中一个操作数是对象，而另一个是基本类型值，则在比较之前先将对象转为基本类型值，然后再依据前面的规则进行后续的比较; 两个操作数在比较时遵循下列规则 undefined和null是相等的，即：undefined == null; 如果有一个操作数是NaN，那么返回false，即使两个操作数都是NaN,也会返回false; 如果两个操作数是对象，则比较规则跟”===”的比较规则是一样的，除非这两个操作数是同一个对象，则返回true，否则返回false; 此处需要注意的是，NaN == NaN是返回false的，NaN意思是 not a number,也就是说该操作数是一个非数字，这个非数字是不确定的，它的值是未知的，甚至可能根本就不能用javascript的语法表示出来，这样一个未知量是不能用来进行特定比较的，两个未知的东西，如果不能确定它的值是什么，当然不能说 NaN == NaN。那么既然不能用”==”来比较，我们怎么去判定一个变量是不是NaN呢 ，既然不能用相等来判定，那么不妨反其道而行之，用”!=”来判定，判定一个变量是否不等于NaN。比如： //如果需要判定一个变量是不是NaN,可以如下//a是你需要判定的变量if((typeof a === \"number\") &amp;&amp; a != NaN )&#123; //此处需要注意，NaN也是number类型 //TODO &#125; 4.常见比较情况及其结果null == undefined // true \"NaN\" == NaN // false 5 == NaN // false NaN == NaN // false NaN != NaN // true false == 0 // true true == 1 // true true == 2 // false undefined == 0 // false null == 0 // false\"5\" == 5 // true 5.典型例题解析![] == [] //true 这是一道比较容易令人困惑的题，按照正常的思维模式，对一个操作数逻辑取反，跟这个操作数本身的值是相对的，如果这个操作数本身的值是true,那么取反之后就是false，反之，如果这个操作数的值是false，那么对其逻辑取反之后就是true，无论如何也不会是同一个值，可是事实上却是![] == []。首先，![]的值是false，因为这里[]被当成了一个数组的实例，是一个对象，而对象都是真值，对其取反，得到一个假值，也就是false。其次看等号右边，[]是一个对象，要将其转为基本类型值，会先调用数组的valueOf方法，而数组的valueOf方法返回数组本身，没有得到一个基本值，这时候要继续调用数组的toString方法，得到一个””空字符串，所以这时候也就变成了false == “”是否为真的问题了，而根据前面的规则，如果有一个操作数为boolean值，会将其转为数值，false转化为0。进而，问题转化为0 == “”是否为真值的问题，当number和string比较时，会将string转为number，而””会转为0。最后，问题变演化成了0 == 0是否为真值，毋庸置疑，结果是true。这里要注意的就是![]，它被当成了一个整体的逻辑值，是直接对对象进行取反，是一个假值，而不是先把[]转化为基本值再取反 6.小结“==”在比较不同类型值得时候会进行隐式的类型转化，而”===”不会转化，全等一定相等，相等却不一定全等，这是一个充分不必要条件。undefined和null相等而不全等，且在相等比较的时候不会转化为其他类型的值。NaN是不等于NaN 的，要判断某个变量是不是NaN，要用”!=”。对象和非对象在进行比较的时候会先转为基本类型值然后再根据上面的规则进行比较。 7.参考资料 《javascript高级程序设计》 《javascript权威指南》","tags":[{"name":"javascript","slug":"javascript","permalink":"http://tiantang-tt.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://tiantang-tt.github.io/tags/js/"},{"name":"ecmascript","slug":"ecmascript","permalink":"http://tiantang-tt.github.io/tags/ecmascript/"},{"name":"相等","slug":"相等","permalink":"http://tiantang-tt.github.io/tags/相等/"},{"name":"全等","slug":"全等","permalink":"http://tiantang-tt.github.io/tags/全等/"},{"name":"js中的相等操作符","slug":"js中的相等操作符","permalink":"http://tiantang-tt.github.io/tags/js中的相等操作符/"},{"name":"js中的相等和全等","slug":"js中的相等和全等","permalink":"http://tiantang-tt.github.io/tags/js中的相等和全等/"}]},{"title":"Hello World","date":"2015-12-31T16:00:00.000Z","path":"2016/01/01/hello-world/","text":"开始我的博客 welcome to new world! test on Christmas Eve 2016","tags":[]}]